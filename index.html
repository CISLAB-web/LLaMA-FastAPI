<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI í”¼ë¶€ ì§„ë‹¨ ì‹œìŠ¤í…œ</title>
  <style>
    body {
      background: #1c1c1e;
      color: white;
      font-family: sans-serif;
      max-width: 960px;
      width: 100%;
      margin: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    h2 { text-align: center; }
    .image-container {
      background: #444;
      border-radius: 8px;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    video, img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .chat-box {
      background: #2a2a2c;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      height: 250px;
      overflow-y: auto;
      font-size: 14px;
    }
    .chat-box p { margin: 8px 0; }
    .user { color: #99c1ff; }
    .assistant { color: #ffd479; }
    .input-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    input[type="text"] {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: none;
    }
    button {
      padding: 8px 14px;
      background: #4f6df5;
      border: none;
      border-radius: 6px;
      color: white;
      cursor: pointer;
    }

    /* ===  ê²°ê³¼ íŒ¨ë„ ìŠ¤íƒ€ì¼ === */
    .metrics-panel{
      background:#2a2a2c;
      border-radius:8px;
      margin-top:12px;
      padding:12px 14px;
    }
    .metrics-title{
      font-weight:600;
      margin-bottom:8px;
      opacity:.9;
    }
    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:10px;
    }
    .metric-card{
      background:#1f1f21;
      border:1px solid #3a3a3c;
      border-radius:10px;
      padding:10px;
      text-align:center;
    }
    .metric-label{
      font-size:12px;
      color:#aaa;
      margin-bottom:6px;
    }
    .metric-value{
      font-size:18px;
      font-weight:700;
    }
    @media (max-width: 640px){
      .metrics-grid{ grid-template-columns:repeat(2,1fr); }
    }
  </style>
</head>
<body>
  <h2>AI ê¸°ë°˜ í”¼ë¶€ ìƒíƒœ ë¶„ì„ ë° ìŠ¤ë§ˆíŠ¸ ì¼€ì–´ ì†”ë£¨ì…˜</h2>

  <p>ì¹´ë©”ë¼ ë˜ëŠ” ì´ë¯¸ì§€ ì—…ë¡œë“œ</p>
  <div class="image-container">
    <video id="video" autoplay muted playsinline style="display: none;"></video>
    <img id="previewImage" src="" style="display: none;">
  </div>

  <!--  ê²°ê³¼ íŒ¨ë„ -->
  <div id="metricsPanel" class="metrics-panel" style="display:none;">
    <div class="metrics-title">ì¸¡ì • ê²°ê³¼</div>
    <div class="metrics-grid">
      <div class="metric-card">
        <div class="metric-label" id="ml1">Metric 1</div>
        <div class="metric-value" id="mv1">-</div>
      </div>
      <div class="metric-card">
        <div class="metric-label" id="ml2">Metric 2</div>
        <div class="metric-value" id="mv2">-</div>
      </div>
      <div class="metric-card">
        <div class="metric-label" id="ml3">Metric 3</div>
        <div class="metric-value" id="mv3">-</div>
      </div>
      <div class="metric-card">
        <div class="metric-label" id="ml4">Metric 4</div>
        <div class="metric-value" id="mv4">-</div>
      </div>
    </div>
  </div>

  <div style="margin-top:10px; display:flex; gap:8px;">
    <button onclick="takePhoto()">ğŸ“¸ ì‚¬ì§„ ì°ê¸°</button>
    <button id="switchBtn" onclick="switchCamera()">ğŸ”„ ì¹´ë©”ë¼ ì „í™˜</button>
  </div>

  <input type="file" id="imageInput" accept="image/*" capture="environment">
  <canvas id="canvas" width="512" height="512" style="display: none;"></canvas>

  <button onclick="analyzeImage()" style="margin-top:20px;">í”¼ë¶€ ë¶„ì„ ì‹œì‘</button>

  <div class="chat-box" id="chatBox"></div>

  <!-- ë¡œë”© í‘œì‹œ -->
  <div id="loading" style="display:none; margin-top:10px; text-align:center; color:#aaa;">
    â³ ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...
  </div>

  <div class="input-row">
    <input type="text" id="userInput" placeholder="ì˜ˆ: í”¼ë¶€ê°€ ì–´ë‘ì›Œìš”, ì–´ë–¤ ì œí’ˆì„ ì¶”ì²œí•´ìš”?">
    <button onclick="sendQuestion()">ì§ˆë¬¸ ë³´ë‚´ê¸°</button>
  </div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
  let chatHistory = [];
  let previewImageBlob = null;
  let videoStream = null;

  // === ì¥ë¹„ ì„ íƒ ìƒíƒœ ===
  let currentDeviceId = null;
  let videoInputs = []; // { deviceId, label }

  const RESOLUTION_PREF = {
    width:  { ideal: 1920 },
    height: { ideal: 1080 },
  };

  const isFrontLabel = (label = "") => /front|user|ì „ë©´|ì•|è‡ªæ‹|å‰ç½®/i.test(label);
  const isBackLabel  = (label = "") => /back|rear|environment|í›„ë©´|ë’¤|åç½®/i.test(label);

  function updateSwitchBtnVisibility() {
    const btn = document.getElementById("switchBtn");
    if (!btn) return;
    if (videoInputs.length < 2) {
      btn.disabled = true;
      btn.title = "ì´ ì¥ì¹˜ëŠ” ì¹´ë©”ë¼ê°€ 1ê°œì…ë‹ˆë‹¤.";
    } else {
      btn.disabled = false;
      btn.title = "";
    }
  }

  async function ensurePermissionProbe() {
    try {
      const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      tmp.getTracks().forEach(t => t.stop());
    } catch (_) {}
  }

  async function enumerateVideoInputs() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    videoInputs = devices.filter(d => d.kind === "videoinput");
    updateSwitchBtnVisibility();
    return videoInputs;
  }

  async function upgradeTrackResolution(track) {
    if (!track || !track.getCapabilities || !track.applyConstraints) return;
    try {
      const caps = track.getCapabilities();
      const maxW = caps.width?.max;
      const maxH = caps.height?.max;
      const target = {
        width:  maxW || RESOLUTION_PREF.width,
        height: maxH || RESOLUTION_PREF.height,
      };
      await track.applyConstraints(target);
    } catch (e) {
      console.warn("í•´ìƒë„ ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨, ì´ˆê¸° í•´ìƒë„ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤ï¼š", e);
    }
  }

  function waitVideoMetadata(video) {
    return new Promise((resolve) => {
      if (video.readyState >= 2 && video.videoWidth && video.videoHeight) return resolve();
      const handler = () => {
        video.removeEventListener('loadedmetadata', handler);
        resolve();
      };
      video.addEventListener('loadedmetadata', handler);
    });
  }

  async function openByDeviceId(deviceId) {
    stopCamera();
    videoStream = await navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: deviceId }, ...RESOLUTION_PREF },
      audio: false
    });
    const video = document.getElementById("video");
    const img = document.getElementById("previewImage");
    const track = videoStream.getVideoTracks()[0];

    await upgradeTrackResolution(track);

    currentDeviceId = (track.getSettings && track.getSettings().deviceId) || deviceId;
    video.setAttribute("playsinline", "");
    video.setAttribute("muted", "");
    video.srcObject = videoStream;
    await waitVideoMetadata(video);
    await video.play();
    video.style.display = "block";
    img.style.display = "none";
  }

  async function forceSwitchToFrontIfNeeded() {
    const track = videoStream?.getVideoTracks?.()[0];
    if (!track) return;

    const settings = track.getSettings ? track.getSettings() : {};
    const facing = (settings.facingMode || "").toLowerCase();
    const curr = videoInputs.find(d => d.deviceId === currentDeviceId);
    const label = curr?.label || "";

    if (facing === "user" || isFrontLabel(label)) return;

    await enumerateVideoInputs();
    if (videoInputs.length < 2) return;

    let front = videoInputs.find(d => isFrontLabel(d.label));
    if (!front && videoInputs.length === 2) {
      front = videoInputs.find(d => d.deviceId !== currentDeviceId);
    }

    if (front) {
      try {
        await openByDeviceId(front.deviceId);
        return;
      } catch (e) {
        console.warn("å¼ºåˆ¶åˆ‡å‰ç½®å¤±è´¥ï¼ˆby deviceIdï¼‰ï¼Œå°è¯•å…œåº•ï¼š", e);
      }
    }

    try {
      stopCamera();
      videoStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { exact: "user" }, ...RESOLUTION_PREF },
        audio: false
      });
      const track2 = videoStream.getVideoTracks()[0];
      await upgradeTrackResolution(track2);
      currentDeviceId = (track2.getSettings && track2.getSettings().deviceId) || null;
      const video = document.getElementById("video");
      video.setAttribute("playsinline", "");
      video.setAttribute("muted", "");
      video.srcObject = videoStream;
      await waitVideoMetadata(video);
      await video.play();
      document.getElementById("video").style.display = "block";
      document.getElementById("previewImage").style.display = "none";
    } catch (e2) {
      console.warn("facingMode:user å…œåº•ä¹Ÿå¤±è´¥ï¼Œå¯èƒ½è¯¥æœºå‹é™åˆ¶å¼ºåˆ¶åˆ‡æ¢ã€‚", e2);
    }
  }

  async function startCamera(prefer = "user") {
    const video = document.getElementById("video");
    const img = document.getElementById("previewImage");

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert("í˜„ì¬ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
      return;
    }

    try {
      await ensurePermissionProbe();
      await enumerateVideoInputs();

      if (videoInputs.length === 1) {
        try {
          await openByDeviceId(videoInputs[0].deviceId);
          return;
        } catch (e) {
          console.warn("å•æ‘„åƒå¤´ deviceId æ‰“å¼€å¤±è´¥ï¼Œå›é€€åˆ° {video:true}:", e);
          stopCamera();
          videoStream = await navigator.mediaDevices.getUserMedia({ video: { ...RESOLUTION_PREF }, audio: false });
          const track = videoStream.getVideoTracks()[0];
          await upgradeTrackResolution(track);
          currentDeviceId = (track.getSettings && track.getSettings().deviceId) || null;
          video.setAttribute("playsinline", "");
          video.setAttribute("muted", "");
          video.srcObject = videoStream;
          await waitVideoMetadata(video);
          await video.play();
          video.style.display = "block";
          img.style.display = "none";
          return;
        }
      }

      try {
        stopCamera();
        videoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: "user" }, ...RESOLUTION_PREF },
          audio: false
        });
      } catch {
        try {
          stopCamera();
          videoStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user", ...RESOLUTION_PREF },
            audio: false
          });
        } catch {
          stopCamera();
          videoStream = await navigator.mediaDevices.getUserMedia({
            video: { ...RESOLUTION_PREF },
            audio: false
          });
        }
      }

      const track = videoStream.getVideoTracks()[0];
      await upgradeTrackResolution(track);
      currentDeviceId = (track.getSettings && track.getSettings().deviceId) || null;

      video.setAttribute("playsinline", "");
      video.setAttribute("muted", "");
      video.srcObject = videoStream;
      await waitVideoMetadata(video);
      await video.play();

      video.style.display = "block";
      img.style.display = "none";

      await forceSwitchToFrontIfNeeded();

    } catch (err) {
      const name = (err && err.name) || "Error";
      const map = {
        NotAllowedError: "ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ê¶Œí•œ/ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.",
        NotFoundError: "ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë©”ë¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        NotReadableError: "ë‹¤ë¥¸ ì•±ì´ ì¹´ë©”ë¼ë¥¼ ì‚¬ìš© ì¤‘ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        OverconstrainedError: "ìš”ì²­í•œ ì¹´ë©”ë¼ ì¡°ê±´ì„ ë§Œì¡±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        SecurityError: "ë³´ì•ˆ ì •ì±…ì— ì˜í•´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤(HTTPS/iframe/Permissions-Policy í™•ì¸)."
      };
      alert((map[name] || "ì¹´ë©”ë¼ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.") + `\n(${name})`);
      console.error(err);
    }
  }

  function stopCamera() {
    if (videoStream) {
      videoStream.getTracks().forEach(track => track.stop());
      videoStream = null;
    }
  }

  async function switchCamera() {
    await enumerateVideoInputs();
    if (videoInputs.length < 2) {
      alert("ì´ ì¥ì¹˜ëŠ” ì¹´ë©”ë¼ê°€ 1ê°œì…ë‹ˆë‹¤. ì „í™˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }
    const now = videoInputs.find(d => d.deviceId === currentDeviceId);
    const isFrontNow = isFrontLabel(now?.label || "");
    let target = videoInputs.find(d => (isFrontNow ? isBackLabel(d.label) : isFrontLabel(d.label)));
    if (!target && videoInputs.length === 2) {
      target = videoInputs.find(d => d.deviceId !== currentDeviceId);
    }
    if (target) {
      try {
        await openByDeviceId(target.deviceId);
      } catch (e) {
        console.warn("åˆ‡æ¢å¤±è´¥ï¼š", e);
      }
    }
  }

  async function snapFullResIfSupported() {
    if (!videoStream) return null;
    const track = videoStream.getVideoTracks()[0];
    if (!("ImageCapture" in window)) return null;
    try {
      const ic = new ImageCapture(track);
      if (ic.takePhoto) {
        return await ic.takePhoto();
      } else if (ic.grabFrame) {
        const bitmap = await ic.grabFrame();
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        canvas.getContext("2d").drawImage(bitmap, 0, 0);
        return await new Promise(r => canvas.toBlob(r, "image/png"));
      }
    } catch (e) {
      console.warn("ImageCapture æ‹ç…§å¤±è´¥ï¼Œå›é€€ canvasï¼š", e);
    }
    return null;
  }

  async function takePhoto() {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");

    if (!videoStream || !video.srcObject) {
      startCamera("user").then(() => {
        if (!videoStream) return;
        alert("ì¹´ë©”ë¼ë¥¼ ì—´ì—ˆìŠµë‹ˆë‹¤. í•œ ë²ˆ ë” 'ì‚¬ì§„ ì°ê¸°'ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
      });
      return;
    }

    const fullBlob = await snapFullResIfSupported();
    if (fullBlob) {
      const useFull = confirm("ì´ ì‚¬ì§„ì„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
      if (useFull) {
        previewImageBlob = fullBlob;
        const img = document.getElementById("previewImage");
        img.src = URL.createObjectURL(fullBlob);
        img.style.display = "block";
        video.style.display = "none";
        stopCamera();
        return;
      }
    }

    const track = videoStream.getVideoTracks()[0];
    const settings = track.getSettings ? track.getSettings() : {};
    const w = video.videoWidth  || settings.width  || 1280;
    const h = video.videoHeight || settings.height || 720;

    canvas.width = w;
    canvas.height = h;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);

    canvas.toBlob(blob => {
      if (!blob) return;
      const use = confirm("ì´ ì‚¬ì§„ì„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?");
      if (use) {
        previewImageBlob = blob;
        const img = document.getElementById("previewImage");
        img.src = URL.createObjectURL(blob);
        img.style.display = "block";
        video.style.display = "none";
        stopCamera();
      }
    }, "image/png");
  }

  document.getElementById("imageInput").addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
      previewImageBlob = file;
      const reader = new FileReader();
      reader.onload = () => {
        document.getElementById("previewImage").src = reader.result;
        document.getElementById("previewImage").style.display = "block";
        document.getElementById("video").style.display = "none";
        stopCamera();
      };
      reader.readAsDataURL(file);
    }
  });


  //   data.metrics = {Glossiness:0.71, Moisture:0.43, Sebum:0.12, Elasticity:0.55}
  //   æˆ– data.metrics = [["Glossiness",0.71],["Moisture",0.43],["Sebum",0.12],["Elasticity",0.55]]
  function updateMetricsFromResponse(data){
    const panel = document.getElementById("metricsPanel");
    if(!data) return;

    let items = null;
    if (Array.isArray(data.metrics)) {
      items = data.metrics.slice(0,4);
    } else if (data.metrics && typeof data.metrics === 'object') {
      items = Object.entries(data.metrics).slice(0,4);
    } else if (Array.isArray(data.results)) {
      items = data.results.slice(0,4);
    } else if (data.results && typeof data.results === 'object') {
      items = Object.entries(data.results).slice(0,4);
    }
    if(!items) return;

    while(items.length < 4) items.push([`Metric ${items.length+1}`, "-"]);

    const labels = [document.getElementById("ml1"), document.getElementById("ml2"),
                    document.getElementById("ml3"), document.getElementById("ml4")];
    const values = [document.getElementById("mv1"), document.getElementById("mv2"),
                    document.getElementById("mv3"), document.getElementById("mv4")];

    items.slice(0,4).forEach((pair, idx) => {
      const name = Array.isArray(pair) ? pair[0] : `Metric ${idx+1}`;
      const val  = Array.isArray(pair) ? pair[1] : pair;
      labels[idx].textContent = name;
      values[idx].textContent = (typeof val === 'number') ? val.toFixed(2) : `${val}`;
    });

    panel.style.display = "block";
  }

  // ====== ë¶„ì„ ë…¼ë¦¬ ======
  async function analyzeImage() {
    if (!previewImageBlob) {
      alert("ì‚¬ì§„ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ì´¬ì˜í•´ì£¼ì„¸ìš”!");
      return;
    }

    document.getElementById("loading").style.display = "block";

    const formData = new FormData();
    formData.append("file", previewImageBlob, "input.png");

    const res = await fetch("/api/analyze", {
      method: "POST",
      body: formData
    });

    const data = await res.json();
    document.getElementById("loading").style.display = "none";

    document.getElementById("previewImage").src = "data:image/png;base64," + data.image_base64;
    document.getElementById("previewImage").style.display = "block";
    document.getElementById("video").style.display = "none";

    updateMetricsFromResponse(data);

    if (data.error) {
      chatHistory = data.chat_history || [
        { role: "assistant", content: data.message || "ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." }
      ];
      renderChat();
      return;
    }

    const defaultQuestion = "ë‚´ í”¼ë¶€ ì¸¡ì •ì¹˜ ë°ì´í„°ê°€ ì–´ëŠ ë°”ìš°ë§Œ ëª¨ë¸ì˜ íƒ€ì… ì¸ì§€ 16ê°€ì§€ ì¤‘ì— ì•Œë ¤ì£¼ê³  ê·¸ íƒ€ì…ì´ ì–´ë–¤ íŠ¹ì§•ì„ ê°€ì§€ê³  ìˆëŠ”ì§€ ì¹œê·¼í•˜ê³  ìì„¸íˆ 2ë¬¸ì¥ìœ¼ë¡œ ë¶„ì„í•´ì¤˜. í™”ì¥í’ˆ, í”¼ë¶€ê³¼ì˜ ì¶”ì²œ ì‹œìˆ , ì „ë¬¸ í”¼ë¶€ë§ˆì‚¬ì§€ í˜¹ì€ í”¼ë¶€ì¼€ì–´ì— ëŒ€í•´ì„œ ìˆœì„œëŒ€ë¡œ ì•Œë ¤ì¤˜. í™”ì¥í’ˆì€ í† ë„ˆ/ìŠ¤í‚¨ â†’ ì—ì„¼ìŠ¤/ì•°í”Œ â†’ ë¡œì…˜ â†’ í¬ë¦¼ ìˆœìœ¼ë¡œ 4ê°€ì§€ëŠ” ê¼­ í•­ëª©ë³„ë¡œ 2ê°€ì§€ ì´ìƒ ì¶”ì²œí•´ì¤¬ìœ¼ë©´ ì¢‹ê² ê³  ì¶”ê°€ì ìœ¼ë¡œ ë„ˆê°€ í•œê°€ì§€ì—ì„œ ë‘ê°€ì§€ ì •ë„ ì¶”ì²œí•´ì¤˜ë„ ë˜. ì¶”ì²œí•˜ëŠ” í™”ì¥í’ˆì˜ ì „ì„±ë¶„ì„ ì¡°ê¸ˆì´ë‚˜ë§ˆ ì„¤ëª…í•´ì¤˜. ì‹¤ì œ í™”ì¥í’ˆì„ ì˜¬ë¦¬ë¸Œì˜, í™”í•´ì—ì„œ ì°¾ì•„ì„œ ì œí’ˆëª…ì„ ìˆœì„œëŒ€ë¡œ ì•Œë ¤ì¤˜. í”¼ë¶€ê³¼ ì‹œìˆ ì€ ì–´ë–¤ ì‹œìˆ ì¸ì§€ë„ ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í•´ì£¼ë©´ì„œ ë¹„ìš©ê³¼ ì¶”ì²œí•˜ëŠ” ìš©ëŸ‰ í˜¹ì€ ìƒ·ìˆ˜ë¥¼ ìƒì„¸íˆ ì•Œë ¤ì¤˜. ì¶”ì²œí•˜ëŠ” ì „ë¬¸ í”¼ë¶€ë§ˆì‚¬ì§€(ì—ìŠ¤í…Œí‹±) í˜¹ì€ í”¼ë¶€ì¼€ì–´ì— ëŒ€í•´ì„œë„ ì„¤ëª…í•´ì¤˜! ì—ìŠ¤í…Œí‹±ì˜ ìœ„ì¹˜ì •ë³´ë‚˜ ìƒ¾ì˜ ì •í™•í•œ ëª…ì¹­ì€ ì•„ì§ ë§í•˜ì§€ë§ˆ!";
    chatHistory = [{ role: "user", content: defaultQuestion }];
    renderChat();

    const response = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ history: [], user_input: defaultQuestion })
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let buffer = "";

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      let lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.trim()) continue;
        try {
          const data = JSON.parse(line);
          chatHistory = data.chat_history;
          renderChat();
        } catch (e) {
          console.warn("è§£æå¤±è´¥:", e);
        }
      }
    }
  }

  // ====== ë¬¸ì œ ì „ì†¡ ======
  async function sendQuestion() {
    const inputField = document.getElementById("userInput");
    const sendButton = document.querySelector(".input-row button");

    const userInput = inputField.value.trim();
    if (!userInput) return;

    inputField.disabled = true;
    sendButton.disabled = true;
    document.getElementById("loading").style.display = "block";

    renderChat();
    inputField.value = "";

    const response = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ history: chatHistory, user_input: userInput })
    });

    const reader = response.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let buffer = "";

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      let lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.trim()) continue;
        try {
          const data = JSON.parse(line);
          chatHistory = data.chat_history;
          renderChat();
        } catch (e) {
          console.warn("íŒŒì‹± ì˜¤ë¥˜:", e);
        }
      }
    }

    inputField.disabled = false;
    sendButton.disabled = false;
    document.getElementById("loading").style.display = "none";
  }

  function renderChat() {
    const box = document.getElementById("chatBox");
    box.innerHTML = "";

    // ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œìŠ¤í…œì´ ìƒì„±í•œ ì•ì˜ 3ê°œ ë‚´ìš©ì„ ê±´ë„ˆëœë‹ˆë‹¤
    let startIdx = 0;

    if (chatHistory.length >= 4){
      startIdx = 3;
      for (let i = startIdx; i < chatHistory.length; i++) {
        const msg = chatHistory[i];
        const p = document.createElement("p");
        p.className = msg.role;
        const contentHTML = marked.parse(msg.content);
        p.innerHTML = `<strong>${msg.role === "user" ? "ğŸ™‹â€â™€ï¸ ë‚˜" : "ğŸ¤– AI"}:</strong> ${contentHTML}`;
        box.appendChild(p);
      }

      box.querySelectorAll("a").forEach(a => {
        a.setAttribute("target", "_blank");
        a.setAttribute("rel", "noopener noreferrer");
      });

      box.scrollTop = box.scrollHeight;
    }
   }

  document.addEventListener("DOMContentLoaded", () => {
    const input = document.getElementById("userInput");
    input.addEventListener("keydown", (e) => {
      if (e.isComposing) return;
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        const sendBtn = document.querySelector(".input-row button");
        if (sendBtn.disabled) return;
        sendQuestion();
      }
    });

    startCamera("user");
  });
</script>
</body>
</html>
